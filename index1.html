<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FakeChain - Distributed Blockchain System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            100: '#1e293b',
                            200: '#0f172a',
                            300: '#0a0f1c',
                        },
                        primary: {
                            500: '#3b82f6',
                            600: '#2563eb',
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-dark-200 text-gray-200 min-h-screen">
    <!-- Navigation - Fixed at top -->
    <nav class="bg-dark-300 border-b border-gray-700 fixed top-0 left-0 right-0 z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fab fa-bitcoin text-primary-500 text-2xl"></i>
                <span class="text-xl font-bold">FakeChain</span>
            </div>
            <div class="flex space-x-6">
                <a href="#" class="text-primary-500 font-medium">Dashboard</a>
                <a href="#blocks" class="hover:text-primary-500 transition">Blocks</a>
                <a href="#transactions" class="hover:text-primary-500 transition">Transactions</a>
                <a href="#admin" class="hover:text-primary-500 transition">Admin</a>
            </div>
            <div class="flex items-center space-x-4">
                <div class="bg-dark-100 px-3 py-1 rounded-full">
                    <span class="text-sm">Network: FakeNet</span>
                </div>
                <button id="syncBlockchain" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg font-medium transition">
                    <i class="fas fa-sync-alt mr-2"></i>Sync Chain
                </button>
                <button id="connectWallet" class="bg-primary-500 hover:bg-primary-600 px-4 py-2 rounded-lg font-medium transition">
                    Connect Wallet
                </button>
            </div>
        </div>
    </nav>

    <!-- Main content with padding to account for fixed nav -->
    <div class="container mx-auto px-4 py-8 mt-16">
        <!-- Network Status -->
        <div class="mb-6 p-4 bg-dark-100 rounded-lg border border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2">
                        <div id="networkStatus" class="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
                        <span class="text-sm">Connected to Network</span>
                    </div>
                    <div class="text-sm text-gray-400">
                        Peers: <span id="peerCount">12</span> | Block Height: <span id="blockHeight">0</span>
                    </div>
                </div>
                <div class="text-sm text-gray-400">
                    Last Sync: <span id="lastSync">Just now</span>
                </div>
            </div>
        </div>

        <!-- Dashboard -->
        <section id="dashboard" class="mb-12">
            <h1 class="text-3xl font-bold mb-6">Blockchain Dashboard</h1>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                <div class="bg-dark-100 p-6 rounded-xl border border-gray-700">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">Current Block</h3>
                        <i class="fas fa-cube text-primary-500 text-xl"></i>
                    </div>
                    <p class="text-3xl font-bold" id="currentBlock">#0</p>
                    <p class="text-gray-400 mt-2">Blocks in chain</p>
                </div>
                
                <div class="bg-dark-100 p-6 rounded-xl border border-gray-700">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">Total Transactions</h3>
                        <i class="fas fa-exchange-alt text-primary-500 text-xl"></i>
                    </div>
                    <p class="text-3xl font-bold" id="totalTransactions">0</p>
                    <p class="text-gray-400 mt-2">All time transactions</p>
                </div>
                
                <div class="bg-dark-100 p-6 rounded-xl border border-gray-700">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">Network Hash Rate</h3>
                        <i class="fas fa-server text-primary-500 text-xl"></i>
                    </div>
                    <p class="text-3xl font-bold">125.6 TH/s</p>
                    <p class="text-gray-400 mt-2">Estimated network power</p>
                </div>
            </div>
            
            <div class="bg-dark-100 p-6 rounded-xl border border-gray-700">
                <h2 class="text-xl font-bold mb-4">Wallet Information</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <div class="mb-4">
                            <label class="block text-gray-400 mb-2">Your Address</label>
                            <div class="flex items-center">
                                <input type="text" id="walletAddress" readonly class="bg-dark-200 border border-gray-700 rounded-lg px-4 py-2 w-full text-sm font-mono" value="Generating...">
                                <button id="copyAddress" class="ml-2 bg-dark-300 hover:bg-dark-200 p-2 rounded-lg transition">
                                    <i class="fas fa-copy"></i>
                                </button>
                                <button id="newWallet" class="ml-2 bg-dark-300 hover:bg-dark-200 p-2 rounded-lg transition" title="Generate New Wallet">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                            </div>
                        </div>
                        
                        <div class="mb-4">
                            <label class="block text-gray-400 mb-2">Balance</label>
                            <div class="flex items-center">
                                <span id="walletBalance" class="text-2xl font-bold">0.00</span>
                                <span class="ml-2 text-gray-400">FKC</span>
                            </div>
                        </div>

                        <div class="mb-4">
                            <label class="block text-gray-400 mb-2">Wallet Created</label>
                            <div class="flex items-center">
                                <span id="walletCreated" class="text-sm text-gray-400">-</span>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-lg font-semibold mb-4">Send Transaction</h3>
                        <div class="mb-4">
                            <label class="block text-gray-400 mb-2">Recipient Address</label>
                            <input type="text" id="recipientAddress" class="bg-dark-200 border border-gray-700 rounded-lg px-4 py-2 w-full" placeholder="0x...">
                        </div>
                        <div class="mb-4">
                            <label class="block text-gray-400 mb-2">Amount (FKC)</label>
                            <input type="number" id="sendAmount" class="bg-dark-200 border border-gray-700 rounded-lg px-4 py-2 w-full" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <button id="sendTransaction" class="bg-primary-500 hover:bg-primary-600 px-4 py-2 rounded-lg w-full font-medium transition">
                            Send FakeCoins
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Blocks Section -->
        <section id="blocks" class="mb-12">
            <h2 class="text-2xl font-bold mb-6">Latest Blocks</h2>
            <div class="bg-dark-100 rounded-xl border border-gray-700 overflow-hidden">
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead class="bg-dark-300 border-b border-gray-700">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Block</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Timestamp</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Transactions</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Hash</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Miner</th>
                            </tr>
                        </thead>
                        <tbody id="blocksTable" class="divide-y divide-gray-700">
                            <!-- Blocks will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Transactions Section -->
        <section id="transactions" class="mb-12">
            <h2 class="text-2xl font-bold mb-6">Recent Transactions</h2>
            <div class="bg-dark-100 rounded-xl border border-gray-700 overflow-hidden">
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead class="bg-dark-300 border-b border-gray-700">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Hash</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">From</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">To</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Amount</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Status</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Timestamp</th>
                            </tr>
                        </thead>
                        <tbody id="transactionsTable" class="divide-y divide-gray-700">
                            <!-- Transactions will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Admin Section -->
        <section id="admin" class="mb-12">
            <h2 class="text-2xl font-bold mb-6">Admin Functions</h2>
            <div class="bg-dark-100 p-6 rounded-xl border border-gray-700">
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-4">Add Balance to User</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <div class="mb-4">
                                <label class="block text-gray-400 mb-2">User Address</label>
                                <input type="text" id="adminUserAddress" class="bg-dark-200 border border-gray-700 rounded-lg px-4 py-2 w-full" placeholder="0x...">
                            </div>
                            <div class="mb-4">
                                <label class="block text-gray-400 mb-2">Amount (FKC)</label>
                                <input type="number" id="adminAmount" class="bg-dark-200 border border-gray-700 rounded-lg px-4 py-2 w-full" placeholder="0.00" min="0.01" step="0.01">
                            </div>
                        </div>
                        <div>
                            <div class="mb-4">
                                <label class="block text-gray-400 mb-2">Admin Password</label>
                                <input type="password" id="adminPassword" class="bg-dark-200 border border-gray-700 rounded-lg px-4 py-2 w-full" placeholder="Enter admin password">
                            </div>
                            <button id="addBalance" class="bg-primary-500 hover:bg-primary-600 px-4 py-2 rounded-lg w-full font-medium transition mt-6">
                                Add Balance
                            </button>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold mb-4">Mine New Block</h3>
                    <p class="text-gray-400 mb-4">Manually mine a new block to include pending transactions.</p>
                    <button id="mineBlock" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg font-medium transition">
                        Mine Block
                    </button>
                </div>
            </div>
        </section>
    </div>

    <!-- Transaction Modal -->
    <div id="transactionModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-dark-100 rounded-xl border border-gray-700 w-full max-w-2xl mx-4">
            <div class="flex justify-between items-center p-6 border-b border-gray-700">
                <h3 class="text-xl font-bold">Transaction Details</h3>
                <button id="closeModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-6">
                <div id="transactionDetails" class="space-y-4">
                    <!-- Transaction details will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-4 right-4 bg-dark-300 border border-gray-700 rounded-lg p-4 shadow-lg hidden z-50">
        <div class="flex items-center">
            <i id="toastIcon" class="fas fa-info-circle text-primary-500 mr-3"></i>
            <span id="toastMessage">This is a toast message</span>
        </div>
    </div>

    <script>
    // Simulated Backend API (In real implementation, this would be a server)
    class BlockchainAPI {
        constructor() {
            // This simulates a central database
            this.baseURL = 'https://api.fakechain.com'; // Simulated URL
            this.blockchainData = this.loadFromServerStorage();
        }

        // Simulate server storage
        loadFromServerStorage() {
            const stored = localStorage.getItem('fakechain_server_db');
            if (stored) {
                return JSON.parse(stored);
            } else {
                // Initialize with genesis block
                const genesisData = {
                    blocks: [{
                        number: 0,
                        timestamp: new Date().toISOString(),
                        transactions: [],
                        hash: this.generateHash('genesis'),
                        previousHash: '0',
                        miner: '0x0000000000000000000000000000000000000000'
                    }],
                    pendingTransactions: [],
                    wallets: new Map(),
                    currentBlockNumber: 0,
                    totalTransactions: 0,
                    peers: 12,
                    lastBlockTime: new Date().toISOString()
                };
                this.saveToServerStorage(genesisData);
                return genesisData;
            }
        }

        saveToServerStorage(data) {
            // Convert Map to Array for JSON serialization
            const saveData = {
                ...data,
                wallets: Array.from(data.wallets.entries())
            };
            localStorage.setItem('fakechain_server_db', JSON.stringify(saveData));
        }

        generateHash(input) {
            let hash = 0;
            for (let i = 0; i < input.length; i++) {
                const char = input.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return '0x' + Math.abs(hash).toString(16).padStart(64, '0');
        }

        // Simulate API calls with delays
        async simulateAPICall(data, delay = 500) {
            return new Promise((resolve) => {
                setTimeout(() => resolve(data), delay);
            });
        }

        // Get complete blockchain state
        async getBlockchainState() {
            return await this.simulateAPICall({
                success: true,
                data: this.blockchainData
            });
        }

        // Submit a transaction to the network
        async submitTransaction(transaction) {
            this.blockchainData.pendingTransactions.push(transaction);
            this.blockchainData.totalTransactions++;
            this.saveToServerStorage(this.blockchainData);
            
            return await this.simulateAPICall({
                success: true,
                message: "Transaction submitted to network",
                transaction: transaction
            });
        }

        // Mine a new block
        async mineBlock(minerAddress) {
            if (this.blockchainData.pendingTransactions.length === 0) {
                return await this.simulateAPICall({
                    success: false,
                    message: "No pending transactions to mine"
                });
            }

            const blockNumber = this.blockchainData.blocks.length;
            const previousHash = this.blockchainData.blocks[this.blockchainData.blocks.length - 1].hash;

            // Process transactions
            for (const tx of this.blockchainData.pendingTransactions) {
                if (tx.status === 'pending' && tx.type === 'transfer') {
                    const senderWallet = this.blockchainData.wallets.get(tx.from);
                    const receiverWallet = this.blockchainData.wallets.get(tx.to);
                    
                    if (senderWallet && receiverWallet) {
                        senderWallet.balance -= tx.amount;
                        receiverWallet.balance += tx.amount;
                        tx.status = 'confirmed';
                    }
                }
            }

            const newBlock = {
                number: blockNumber,
                timestamp: new Date().toISOString(),
                transactions: [...this.blockchainData.pendingTransactions],
                hash: this.generateHash(`block-${blockNumber}-${Date.now()}-${previousHash}`),
                previousHash: previousHash,
                miner: minerAddress
            };

            this.blockchainData.blocks.push(newBlock);
            this.blockchainData.pendingTransactions = [];
            this.blockchainData.currentBlockNumber = blockNumber;
            this.blockchainData.lastBlockTime = new Date().toISOString();
            
            this.saveToServerStorage(this.blockchainData);

            return await this.simulateAPICall({
                success: true,
                message: `Block #${blockNumber} mined successfully`,
                block: newBlock
            });
        }

        // Add balance (admin function)
        async addBalance(userAddress, amount) {
            if (!this.blockchainData.wallets.has(userAddress)) {
                this.blockchainData.wallets.set(userAddress, {
                    address: userAddress,
                    balance: 0,
                    created: new Date().toISOString()
                });
            }

            const wallet = this.blockchainData.wallets.get(userAddress);
            wallet.balance += parseFloat(amount);

            const transaction = {
                hash: this.generateHash(`admin-${Date.now()}`),
                from: '0x0000000000000000000000000000000000000000',
                to: userAddress,
                amount: parseFloat(amount),
                timestamp: new Date().toISOString(),
                status: 'confirmed',
                type: 'admin'
            };

            this.blockchainData.pendingTransactions.push(transaction);
            this.blockchainData.totalTransactions++;
            
            this.saveToServerStorage(this.blockchainData);

            return await this.simulateAPICall({
                success: true,
                message: `Added ${amount} FKC to ${userAddress}`
            });
        }

        // Get network info
        async getNetworkInfo() {
            return await this.simulateAPICall({
                peers: this.blockchainData.peers + Math.floor(Math.random() * 5) - 2, // Simulate peer fluctuation
                blockHeight: this.blockchainData.currentBlockNumber,
                lastBlockTime: this.blockchainData.lastBlockTime,
                totalWallets: this.blockchainData.wallets.size
            });
        }
    }

    // Custom Unique Encryption System
    class SecureAdminAuth {
        constructor() {
            this.passwordHash = "00000000000000000000000060203d1e";
        }
        
        complexHash(input) {
            let hash = 0;
            const prime1 = 137;
            const prime2 = 257;
            const prime3 = 65537;
            
            for (let i = 0; i < input.length; i++) {
                const char = input.charCodeAt(i);
                hash = ((hash << 7) - hash + char * prime1) & 0xFFFFFFFF;
                hash = (hash ^ (hash >> 13)) * prime2;
                hash = (hash ^ (hash >> 17)) * prime3;
                hash = hash ^ (hash >> 19);
            }
            
            return Math.abs(hash).toString(16).padStart(32, '0');
        }
        
        transformInput(input) {
            let transformed = "";
            
            for (let i = 0; i < input.length; i++) {
                let charCode = input.charCodeAt(i);
                charCode = (charCode * 7919 + 65537) % 256;
                transformed += String.fromCharCode(charCode);
            }
            
            let xored = "";
            for (let i = 0; i < transformed.length; i++) {
                const keyChar = (i * 123456789) % 256;
                xored += String.fromCharCode(transformed.charCodeAt(i) ^ keyChar);
            }
            
            let rotated = "";
            for (let i = 0; i < xored.length; i++) {
                let byte = xored.charCodeAt(i);
                byte = ((byte << 3) | (byte >> 5)) & 0xFF;
                rotated += String.fromCharCode(byte);
            }
            
            return rotated;
        }
        
        verifyPassword(input) {
            if (!input || input.length < 8) return false;
            
            const transformed = this.transformInput(input);
            const inputHash = this.complexHash(transformed + input.length.toString());
            
            return this.secureCompare(inputHash, this.passwordHash);
        }
        
        secureCompare(a, b) {
            if (a.length !== b.length) return false;
            
            let result = 0;
            for (let i = 0; i < a.length; i++) {
                result |= a.charCodeAt(i) ^ b.charCodeAt(i);
            }
            return result === 0;
        }
    }

    // Enhanced Fake Blockchain Implementation with Network Sync
    class FakeBlockchain {
        constructor() {
            this.api = new BlockchainAPI();
            this.adminAuth = new SecureAdminAuth();
            this.localState = this.loadLocalState();
            this.loadOrCreateWallet();
            this.syncInterval = null;
        }

        // Load local copy of blockchain
        loadLocalState() {
            const stored = localStorage.getItem('fakechain_local_copy');
            if (stored) {
                const data = JSON.parse(stored);
                // Convert wallets array back to Map
                data.wallets = new Map(data.wallets || []);
                return data;
            }
            return null;
        }

        // Save local copy of blockchain
        saveLocalState() {
            const saveData = {
                ...this.localState,
                wallets: Array.from(this.localState.wallets.entries())
            };
            localStorage.setItem('fakechain_local_copy', JSON.stringify(saveData));
        }

        // Sync with network
        async syncWithNetwork() {
            try {
                const response = await this.api.getBlockchainState();
                if (response.success) {
                    this.localState = response.data;
                    // Convert wallets array to Map
                    this.localState.wallets = new Map(this.localState.wallets);
                    this.saveLocalState();
                    return { success: true, message: "Blockchain synced successfully" };
                }
            } catch (error) {
                console.error("Sync error:", error);
                return { success: false, message: "Failed to sync with network" };
            }
        }

        // Get network info
        async getNetworkInfo() {
            return await this.api.getNetworkInfo();
        }

        generateWalletAddress() {
            const chars = '0123456789abcdef';
            let address = '0x';
            for (let i = 0; i < 40; i++) {
                address += chars[Math.floor(Math.random() * chars.length)];
            }
            return address;
        }

        loadOrCreateWallet() {
            const savedWallet = localStorage.getItem('fakechain_wallet');
            
            if (savedWallet) {
                const walletData = JSON.parse(savedWallet);
                this.userWallet = walletData.address;
                this.walletCreated = walletData.created;
                
                // Ensure wallet exists in local state
                if (this.localState && !this.localState.wallets.has(this.userWallet)) {
                    this.localState.wallets.set(this.userWallet, {
                        address: this.userWallet,
                        balance: 0,
                        created: this.walletCreated
                    });
                    this.saveLocalState();
                }
            } else {
                this.createNewWallet();
            }
        }

        createNewWallet() {
            const address = this.generateWalletAddress();
            const created = new Date().toISOString();
            
            this.userWallet = address;
            this.walletCreated = created;
            
            if (this.localState) {
                this.localState.wallets.set(address, {
                    address: address,
                    balance: 0,
                    created: created
                });
                this.saveLocalState();
            }
            
            localStorage.setItem('fakechain_wallet', JSON.stringify({
                address: address,
                created: created
            }));
            
            return address;
        }

        getWalletCreationTime() {
            return this.walletCreated;
        }

        async addBalance(userAddress, amount, password) {
            if (!this.adminAuth.verifyPassword(password)) {
                return { success: false, message: "Invalid admin password" };
            }
            
            const result = await this.api.addBalance(userAddress, amount);
            if (result.success) {
                // Sync local state after successful operation
                await this.syncWithNetwork();
            }
            return result;
        }

        async sendTransaction(from, to, amount) {
            if (!this.localState.wallets.has(from)) {
                return { success: false, message: "Sender wallet not found" };
            }

            const senderWallet = this.localState.wallets.get(from);
            if (senderWallet.balance < parseFloat(amount)) {
                return { success: false, message: "Insufficient balance" };
            }

            const transaction = {
                hash: this.api.generateHash(`tx-${Date.now()}-${from}-${to}`),
                from: from,
                to: to,
                amount: parseFloat(amount),
                timestamp: new Date().toISOString(),
                status: 'pending',
                type: 'transfer'
            };

            const result = await this.api.submitTransaction(transaction);
            if (result.success) {
                // Sync local state after submission
                await this.syncWithNetwork();
            }
            return result;
        }

        async mineBlock() {
            const result = await this.api.mineBlock(this.userWallet);
            if (result.success) {
                // Sync local state after mining
                await this.syncWithNetwork();
            }
            return result;
        }

        getBlocks() {
            return this.localState ? this.localState.blocks.slice().reverse() : [];
        }

        getTransactions() {
            if (!this.localState) return [];
            
            const allTransactions = [];
            for (const block of this.localState.blocks) {
                allTransactions.push(...block.transactions);
            }
            allTransactions.push(...this.localState.pendingTransactions);
            
            return allTransactions.slice().reverse();
        }

        getWalletBalance(address) {
            if (this.localState && this.localState.wallets.has(address)) {
                return this.localState.wallets.get(address).balance;
            }
            return 0;
        }

        getCurrentBlockNumber() {
            return this.localState ? this.localState.currentBlockNumber : 0;
        }

        getTotalTransactions() {
            return this.localState ? this.localState.totalTransactions : 0;
        }

        // Start automatic syncing
        startAutoSync(interval = 30000) {
            this.syncInterval = setInterval(async () => {
                await this.syncWithNetwork();
                updateUI();
            }, interval);
        }

        // Stop automatic syncing
        stopAutoSync() {
            if (this.syncInterval) {
                clearInterval(this.syncInterval);
                this.syncInterval = null;
            }
        }
    }

    // Initialize the blockchain
    const blockchain = new FakeBlockchain();

    // DOM Elements
    const walletAddressElement = document.getElementById('walletAddress');
    const walletBalanceElement = document.getElementById('walletBalance');
    const walletCreatedElement = document.getElementById('walletCreated');
    const currentBlockElement = document.getElementById('currentBlock');
    const totalTransactionsElement = document.getElementById('totalTransactions');
    const blocksTableElement = document.getElementById('blocksTable');
    const transactionsTableElement = document.getElementById('transactionsTable');
    const transactionModal = document.getElementById('transactionModal');
    const transactionDetails = document.getElementById('transactionDetails');
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    const toastIcon = document.getElementById('toastIcon');
    const networkStatus = document.getElementById('networkStatus');
    const peerCount = document.getElementById('peerCount');
    const blockHeight = document.getElementById('blockHeight');
    const lastSync = document.getElementById('lastSync');

    // Initialize the UI
    async function initializeUI() {
        showToast("Connecting to FakeChain network...", "info");
        
        // Initial sync with network
        const syncResult = await blockchain.syncWithNetwork();
        if (syncResult.success) {
            showToast("Blockchain synced successfully", "success");
            networkStatus.className = "w-3 h-3 bg-green-500 rounded-full animate-pulse";
        } else {
            showToast("Failed to sync with network", "error");
            networkStatus.className = "w-3 h-3 bg-red-500 rounded-full";
        }

        // Update network info
        updateNetworkInfo();
        
        walletAddressElement.value = blockchain.userWallet;
        walletCreatedElement.textContent = new Date(blockchain.getWalletCreationTime()).toLocaleString();
        
        updateWalletBalance();
        updateBlockCount();
        updateTransactionCount();
        
        renderBlocks();
        renderTransactions();

        // Start automatic syncing
        blockchain.startAutoSync();

        // Add initial demo balance for new users
        setTimeout(async () => {
            const demoBalanceAdded = localStorage.getItem('demo_balance_added');
            if (!demoBalanceAdded && blockchain.getWalletBalance(blockchain.userWallet) === 0) {
                // Use admin function to add balance
                await blockchain.addBalance(blockchain.userWallet, 100, "admin123"); // Default admin password
                localStorage.setItem('demo_balance_added', 'true');
                updateWalletBalance();
                showToast("Welcome! Demo balance loaded", "success");
            }
        }, 2000);
    }

    // Update network information
    async function updateNetworkInfo() {
        const networkInfo = await blockchain.getNetworkInfo();
        peerCount.textContent = networkInfo.peers;
        blockHeight.textContent = networkInfo.blockHeight;
        lastSync.textContent = "Just now";
    }

    // Update wallet balance display
    function updateWalletBalance() {
        const balance = blockchain.getWalletBalance(blockchain.userWallet);
        walletBalanceElement.textContent = balance.toFixed(2);
    }

    // Update current block display
    function updateBlockCount() {
        currentBlockElement.textContent = `#${blockchain.getCurrentBlockNumber()}`;
    }

    // Update total transactions display
    function updateTransactionCount() {
        totalTransactionsElement.textContent = blockchain.getTotalTransactions();
    }

    // Render blocks table
    function renderBlocks() {
        const blocks = blockchain.getBlocks();
        blocksTableElement.innerHTML = '';
        
        blocks.forEach(block => {
            const row = document.createElement('tr');
            row.className = 'hover:bg-dark-300 transition';
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="font-mono text-primary-500">#${block.number}</span>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    ${new Date(block.timestamp).toLocaleString()}
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    ${block.transactions.length}
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="font-mono text-sm">${block.hash.substring(0, 16)}...</span>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="font-mono text-sm">${block.miner.substring(0, 10)}...</span>
                </td>
            `;
            blocksTableElement.appendChild(row);
        });
    }

    // Render transactions table
    function renderTransactions() {
        const transactions = blockchain.getTransactions();
        transactionsTableElement.innerHTML = '';
        
        transactions.forEach(tx => {
            const row = document.createElement('tr');
            row.className = 'hover:bg-dark-300 transition cursor-pointer';
            row.addEventListener('click', () => showTransactionDetails(tx));
            
            const statusClass = tx.status === 'confirmed' ? 'bg-green-800 text-green-200' : 'bg-yellow-800 text-yellow-200';
            
            const isUserTx = tx.from === blockchain.userWallet || tx.to === blockchain.userWallet;
            if (isUserTx) {
                row.classList.add('bg-dark-300');
            }
            
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="font-mono text-sm">${tx.hash.substring(0, 16)}...</span>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="font-mono text-sm ${tx.from === blockchain.userWallet ? 'text-primary-500' : ''}">${tx.from.substring(0, 10)}...</span>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="font-mono text-sm ${tx.to === blockchain.userWallet ? 'text-primary-500' : ''}">${tx.to.substring(0, 10)}...</span>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    ${tx.amount} FKC
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="px-2 py-1 rounded-full text-xs ${statusClass}">${tx.status}</span>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    ${new Date(tx.timestamp).toLocaleString()}
                </td>
            `;
            transactionsTableElement.appendChild(row);
        });
    }

    // Update entire UI
    function updateUI() {
        updateWalletBalance();
        updateBlockCount();
        updateTransactionCount();
        renderBlocks();
        renderTransactions();
        updateNetworkInfo();
    }

    // Show transaction details in modal
    function showTransactionDetails(transaction) {
        transactionDetails.innerHTML = `
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <p class="text-gray-400">Transaction Hash</p>
                    <p class="font-mono break-all">${transaction.hash}</p>
                </div>
                <div>
                    <p class="text-gray-400">Status</p>
                    <p class="font-semibold ${transaction.status === 'confirmed' ? 'text-green-500' : 'text-yellow-500'}">${transaction.status}</p>
                </div>
                <div>
                    <p class="text-gray-400">From</p>
                    <p class="font-mono break-all ${transaction.from === blockchain.userWallet ? 'text-primary-500' : ''}">${transaction.from}</p>
                </div>
                <div>
                    <p class="text-gray-400">To</p>
                    <p class="font-mono break-all ${transaction.to === blockchain.userWallet ? 'text-primary-500' : ''}">${transaction.to}</p>
                </div>
                <div>
                    <p class="text-gray-400">Amount</p>
                    <p class="font-semibold">${transaction.amount} FKC</p>
                </div>
                <div>
                    <p class="text-gray-400">Timestamp</p>
                    <p>${new Date(transaction.timestamp).toLocaleString()}</p>
                </div>
                ${transaction.type === 'admin' ? `
                <div class="md:col-span-2">
                    <p class="text-gray-400">Type</p>
                    <p class="font-semibold text-primary-500">Admin Balance Addition</p>
                </div>
                ` : ''}
            </div>
        `;
        
        transactionModal.classList.remove('hidden');
    }

    // Show toast notification
    function showToast(message, type = "info") {
        toastMessage.textContent = message;
        
        if (type === "success") {
            toastIcon.className = "fas fa-check-circle text-green-500 mr-3";
        } else if (type === "error") {
            toastIcon.className = "fas fa-exclamation-circle text-red-500 mr-3";
        } else {
            toastIcon.className = "fas fa-info-circle text-primary-500 mr-3";
        }
        
        toast.classList.remove('hidden');
        
        setTimeout(() => {
            toast.classList.add('hidden');
        }, 5000);
    }

    // Event Listeners
    document.getElementById('copyAddress').addEventListener('click', () => {
        navigator.clipboard.writeText(walletAddressElement.value);
        showToast("Address copied to clipboard", "success");
    });

    document.getElementById('newWallet').addEventListener('click', () => {
        if (confirm("Are you sure you want to generate a new wallet? Your current wallet and balance will be lost!")) {
            blockchain.createNewWallet();
            walletAddressElement.value = blockchain.userWallet;
            walletCreatedElement.textContent = new Date(blockchain.getWalletCreationTime()).toLocaleString();
            updateWalletBalance();
            showToast("New wallet generated successfully", "success");
        }
    });

    document.getElementById('sendTransaction').addEventListener('click', async () => {
        const recipient = document.getElementById('recipientAddress').value;
        const amount = document.getElementById('sendAmount').value;
        
        if (!recipient || !amount) {
            showToast("Please fill in all fields", "error");
            return;
        }
        
        if (parseFloat(amount) <= 0) {
            showToast("Amount must be greater than 0", "error");
            return;
        }
        
        const result = await blockchain.sendTransaction(blockchain.userWallet, recipient, amount);
        
        if (result.success) {
            document.getElementById('recipientAddress').value = '';
            document.getElementById('sendAmount').value = '';
            updateUI();
            showToast("Transaction sent successfully", "success");
        } else {
            showToast(result.message, "error");
        }
    });

    document.getElementById('addBalance').addEventListener('click', async () => {
        const userAddress = document.getElementById('adminUserAddress').value;
        const amount = document.getElementById('adminAmount').value;
        const password = document.getElementById('adminPassword').value;
        
        if (!userAddress || !amount || !password) {
            showToast("Please fill in all fields", "error");
            return;
        }
        
        const result = await blockchain.addBalance(userAddress, amount, password);
        
        if (result.success) {
            document.getElementById('adminUserAddress').value = '';
            document.getElementById('adminAmount').value = '';
            document.getElementById('adminPassword').value = '';
            
            updateUI();
            showToast(result.message, "success");
        } else {
            showToast(result.message, "error");
        }
    });

    document.getElementById('mineBlock').addEventListener('click', async () => {
        const result = await blockchain.mineBlock();
        
        if (result.success) {
            updateUI();
            showToast(result.message, "success");
        } else {
            showToast(result.message, "info");
        }
    });

    document.getElementById('syncBlockchain').addEventListener('click', async () => {
        showToast("Syncing with network...", "info");
        const result = await blockchain.syncWithNetwork();
        
        if (result.success) {
            updateUI();
            showToast("Blockchain synced successfully", "success");
        } else {
            showToast("Failed to sync with network", "error");
        }
    });

    document.getElementById('closeModal').addEventListener('click', () => {
        transactionModal.classList.add('hidden');
    });

    document.getElementById('connectWallet').addEventListener('click', () => {
        showToast("Wallet connected successfully", "success");
    });

    transactionModal.addEventListener('click', (e) => {
        if (e.target === transactionModal) {
            transactionModal.classList.add('hidden');
        }
    });

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializeUI);

    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        blockchain.stopAutoSync();
    });
</script>
</body>
</html>
